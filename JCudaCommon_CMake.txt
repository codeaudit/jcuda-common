##############################################################################
# Common CMake settings for all JCuda projects
#

set(JCUDA_CUDA_VERSION 7.5)



##############################################################################
# Set the CMake module path so that FindCUDA.cmake can be found

set(CMAKE_MODULE_PATH 
  "${CMAKE_CURRENT_LIST_DIR}/CMake"
  ${CMAKE_MODULE_PATH})



##############################################################################
# Find the required packages

if (NOT CUDA_FOUND)
    find_package(CUDA ${JCUDA_CUDA_VERSION} REQUIRED)
    
    # Try to find the NVRTC library in the same directory
    # as the CUDA_CUDA_LIBRARY
    get_filename_component(CUDA_LIBRARY_DIR "${CUDA_CUDA_LIBRARY}" PATH)
    find_library(CUDA_nvrtc_LIBRARY nvrtc ${CUDA_LIBRARY_DIR})
endif()

if (NOT JNI_FOUND)
    find_package(JNI REQUIRED)
endif()



##############################################################################
# Define the common JNI include directories
    
set(JCudaCommonJNI_INCLUDE_DIRS 
    ${CMAKE_CURRENT_LIST_DIR}/JCudaCommonJNI/src)


##############################################################################
# Set the output directories for the built libraries: The runtime libraties
# (e.g. the DLLs) will be placed into a subdirectory of the source 
# directory, called "nativeLibrary". This will be done generally (for
# single-configuration compilers), and for all configurations (e.g. RELEASE 
# and MINSIZEREL) for multi-configuration compilers like MSVC). 

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY 
    ${PROJECT_SOURCE_DIR}/nativeLibrary)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY 
    ${PROJECT_SOURCE_DIR}/nativeLibrary)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
foreach(CONFIGURATION_TYPE ${CMAKE_CONFIGURATION_TYPES})
    string(TOUPPER ${CONFIGURATION_TYPE} CONFIGURATION_TYPE)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${CONFIGURATION_TYPE} 
        ${PROJECT_SOURCE_DIR}/nativeLibrary)
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CONFIGURATION_TYPE} 
        ${PROJECT_SOURCE_DIR}/nativeLibrary)
    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${CONFIGURATION_TYPE} 
        ${CMAKE_BINARY_DIR}/lib)
endforeach(CONFIGURATION_TYPE CMAKE_CONFIGURATION_TYPES)




##############################################################################
# Determine the host system, and set the CMAKE_HOST and CMAKE_ARCH variables. 
# These will be used by the individual library CMake files to build the 
# final library name, e.g. "jcuda-windows-x86_64.dll"

if(CMAKE_HOST_WIN32)
  set(CMAKE_HOST "windows")
elseif(CMAKE_HOST_APPLE)
  set(CMAKE_HOST "apple")
  set(CMAKE_SKIP_RPATH FALSE)
elseif(CMAKE_HOST_UNIX)
  set(CMAKE_HOST "linux")
endif()

if(CMAKE_SYSTEM_PROCESSOR MATCHES "ppc*")
  if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(CMAKE_ARCH "ppc_64")
  endif()
else()
  if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(CMAKE_ARCH "x86_64")
  else()
    set(CMAKE_ARCH "x86")
  endif()
endif()


##############################################################################
# The compilation on MacOS >=10.11 and above requires additional
# linker flags. In order to detect whether MacOS >=10.11 is present,
# the underlying Darwin version number is checked here (see
# https://en.wikipedia.org/wiki/Darwin_%28operating_system%29)
# If it is greater than 14, then MacOS 10.11 or greater is running.
# The flags are added ONCE, to the CMAKE_SHARED_LINKER_FLAGS variable
if (NOT CMAKE_CUDA_SHARED_LINKER_FLAGS_INITIALIZED)
    if(CMAKE_HOST_APPLE)
        string(REGEX REPLACE "^([0-9]+)\\.([0-9]+).*$" "\\1" 
            DARWIN_MAJOR_VERSION ${CMAKE_SYSTEM_VERSION})
        if(${DARWIN_MAJOR_VERSION} GREATER 14)    
            set(CMAKE_SHARED_LINKER_FLAGS 
                "${CMAKE_SHARED_LINKER_FLAGS} -Xlinker -F/Library/Frameworks -Xlinker -framework -Xlinker CUDA") 
        endif()
    endif()
    set(CMAKE_CUDA_SHARED_LINKER_FLAGS_INITIALIZED "true")
endif()

